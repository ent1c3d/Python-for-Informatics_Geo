## 5.1 ცვლადების განახლება

ტოლობის ზოგადი ნიმუშია, როცა გატოლება ცვლადს ანახლებს - სადაც ცვლადის ახალი მნიშვნელობა დამოკიდებულია ძველ მნიშვნელობაზე.

```python	
x = x + 1
```

ეს ნიშნავს "აიღე x - ს მნიშვნელობა დაუმატე ერთი და განაახლე x ახალი მნიშვნელობით."  თუ ცდი რომ განაახლო ისეთი ცვლადი, რომელიც არ არსებობს, მიიღებ შეცდომას, იმიტომ რომ პითონი ითვლის მარჯვენა ნაწილს სანამ x - ს გაუტოლებს.

```python	
>>> x = x + 1
NameError: name 'x' is not defined
```

ცვლადს ჯერ მნიშვნელობა უნდა მიანიჭო და შემდეგ შეგეძლება განაახლო.

```python	
>>> x = 0
>>> x = x + 1
```

ცვლადის განახლებას ერთის დამატებით ჰქვია "ზრდა" (an increment) და ერთის გამოკლებით - "კლება" (a decrement.)

## 5.2  while ბრძანება

კომპიუტერები ხშირად იყენებენ ავტომატურად განმეორებად დავალებებს. იდენტური ან მსგავსი დავალებების გამეორება შეცდომის გარეშე კომპიუტერისთვის ადვილია, ადამიანისთვის კი უხეირო. პითონი უზრუნველყოფილია რამდენიმე ენის მახასიათებლებით, რომ განმეორებები გააკეთოს  ადვილად.
პითონში გამეორების ერთ - ერთი ფორმაა while ბრძანება. აქაა მარტივი პროგრამა რომელიც უკუღმა თვლის ხუთიდან და ამბობს “Blastoff!”.

```python	
n = 5
while n > 0:
      print n
      n = n - 1
print 'Blastoff!'
```

შეგიძლია წაიკითხო while  ბრძანება ინგლისურად.  ეს ნიშნავს;  while(სანამ) n მეტია ნულზე, გამოსახე n - ის მნიშვნელობა და მოაკელი 1. როცა მიიღებ ნულს, while  ბრძანება მორჩება და გამოსახავს სიტყვას 'Blastoff!'.
უფრო ფორმალურად აქაა განხორცილებათა დინება while ბრძანებისთვის.

1.  პირობის შეფასება,  True ან False
2.  პირობა თუ მცდარია (False), მორჩეს  while ბრძანებას და განახორციელოს სხვა ბრძანება.
3.  პირობა თუ მართალია, შეასრულე  body კოდი და დაუბრუნდი პირველ ნაბიჯს.

დინები ამ ტიპს ჰქვია მარყუჟი (loop) , იმიტომ რომ მესამე ნაბიჯი ამარყუჟებს. ყოველთვის, როცა ვაკეთებთ მარყუჟს, ამას ვეძახით გამეორებას. ზემო მაგალითზე შეგვიძლია ვთქვათ, რომ იქ იყო 5 გამეორება, რაც ნიშნავს რომ მარყუჟის  სხეული(კოდი) განხორციელდა ხუთჯერ.
მარყუჟის კოდმა ცვლადის ან ცვლადების მნიშვნელობა უნდა ცვალოს მანამ, სანამ პირობა არ გახდება მცდარი და მარყუჟი დასრულდება. ცვლადს, რომელიც მარყუჟის მიერ ყოველ ჯერზე იცვლება ვეძახით გამეორებად ცვლადს. ასეთი ცვლადი თუ არაა, მარყუჟი განმეორდება უსასრულოდ.


## 5.3 უსასრულო მარყუჟი

პროგრამისტების უსასრულო თავშესაქცევია დაკვირვება შამპუნზე. "ქაფი,გარეცხვა, გამეორება" .ესაა უსასრულო მარყუჟი, იმიტომ რომ არაა გამეორებადი ცვლადი, რომელიც გეტყვის რამდენჯერ განხორციელდება მარყუჟი.
უკუღმა თვლის შემთხვევაში შეგვიძლია დავამტკიცოთ, რომ მარყუჟი როდესღაც მორჩება - ვიცით რა n - ის მნიშვნელობა, და  ვხედავთ რომ n - ის მნიშვნელობა მარყუჟის ყოველ შესრულებაზე იკლებს. საბოლოოდ ვიღებთ 0.  სხვა შემთხვევებში მარყუჟი უსასრულოა, იმიტომ რომ არა აქვს განმეორებადი ცვლადი.

## 5.4  "უსასრულო მარყუჟები" და break

ხანდახან არ იცი როდის დამთავრდება მარყუჟი, სანამ კოდის შუაში არ გახვალ. ამ შემთხვევაში შეგიძლია დაწერო უსასრულო მარყუჟი და გამოიყენო break ბრძანება მარყუჟიდან გამოსასვლელად. ეს მარყუჟი აშკარად უსასრულოა, იმიტომ რომ while ბრძანების ლოგიკური გამოსახულება არის მუდმივად True.

```python	
n = 10
while True:
            print n,
            n = n - 1
print 'Done!'
```

თუ მიქარავ და ამ კოდს გაუშვებ, სწრაფად ისწავლი როგორ გათიშო პითონი ან დენიდან გამორთავ კომპიუტერს. ეს პროგრამა იმუშავებს მუდამ, იმიტომ რომ მარყუჟის ზემოთ ლოგიკური გამოსახულება არის ყოველთვის True და ამ ფაქტის ძალით გამოსახულების მუდმივი მნიშვნელობაა True .
სანამ ესაა უფუნქციო უსასრულო მარყუჟი, ჩვენ შეგვიძლია ისევ გამოვიყენოთ ნიმუში  სასარგებლო მარყუჟის გასაკეთებლად  და კოდში ფრთხილად დავამატოთ break ბრძანება, რომელიც შესრულდება მაშინ, როცა კი ამის პირობა შესრულდება.

```python	
while True:
            line = raw_input('> ')
            if line == 'done':
                        break
            print line
print 'Done!'
```

მარყუჟის პირობაა True, რომელიც ყოველთვის მართალია, ამიტომ კოდი იმუშავებს მანამ, სანამ არ მიაღწევს break ბრძანებას. ყოველ ჯერზე  გამოჩნდება ახალი კუთხური ფრჩხილი და მომხმარებელი როცა დაწერს done - ს, break ბრძანება მარყუჟს გათიშავს. სხვა შემთხვევაში პროგრამა ყოველ ჯერზე  ექოსავით გაიმეორებს მომხმარებლის დაწერილს.აქაა მაგალითი:

```python	
> hello there
hello there
> finished
finished
> done
Done!
```

ეს გზა   while  მარყუჟის დასაწერად არის  გავრცელებული, იმიტომ რომ  ყოველთვის შეგიძლია შეამოწმო პირობა, და  შეგიძლია გამოსახო გაჩერების ბრძანება როგორც  დადებითად ("გააჩერე როცა ეს მოხდება") ასევე უარყოფითად ("გააგრძელე სანამ ეს მოხდება")

## 5.5 continue - თი დასრულებული გამეორება

ხანდახან გინდა, რომ გამეორების მარყუჟი (iteration of a loop) მორჩეს და დაუყოვნებლივ გადახტეს სხვა გამეორებაზე. ამ შემთხვევაში შეგიძლია გამოიყენო continue ბრძანება, რომ გადახტე შემდეგ გამეორებაზე, მიმდინარე გამეორების კოდის შესრულების გარეშე. აქაა მარყუჟის მაგალითი, რომელიც აკოპირებს  input-ს, სანამ მომხმარებელი არ დაწერს "done" - ს, თუმცა ხაზი, რომელიც იწყება დიეზის ნიშნით არ ამობეჭდავს (როგორც პითონის კომენტარებს)


```python	
while True:
      line = raw_input('> ')
      if line[0] == '#' :
            continue
      if line == 'done':
            break
      print line
print 'Done!'
```

ნიმუში სადაც დამატებულია continue.

```python	
> hello there
hello there
> # don't print this
> print this!
print this!
> done
```

ყველა ხაზი ამობეჭდილია გარდა იმ ხაზისა, რომელიც დაიწყო დიეზით, იმიტომ რომ, როცა continue ხორციელდება,  ეს ამთავრებს მიმდინარე გამეორებას და ხტება უკან while ბრძანებაზე ახალი გამეორების დასაწყებად. ასე ახტება print ბრძანებას.


## 5.6 განსაზღვრული მარყუჟები იყენებს for -ს

ხანდახან გვინდა გავაკეთოთ მარყუჟი, რათა შევადგინოთ სიტყვების სია ან ხაზები ფაილში ან ციფრების სია. ასეთ დროს შეგვიძლია ავაგოთ განსაზღვრული (definite) მარყუჟი, რომელიც იყენებს for ბრძანებას. while ბრძანებას ვეძახით უსასრულო მარყუჟს, იმიტომ რომ მარტივად ამარყუჟებს, სანამ რამე პირობა არ გახდება False, მაშინ როდესაც for მარყუჟი ამარყუჟებს ნაცნობ ელემენტებს, ასე რომ აკეთებს იმდენ გამეორებას რამდენი ელემენტიცაა მითითებული.
for მარყუჟის სინტაქსი არის while მარყუჟის მსგავსი.


```python	
friends = ['Joseph', 'Glenn', 'Sally']
for friend in friends:
            print 'Happy New Year:', friend
print 'Done!'
```

პითონში ცვლადი friends არის სია1 სამი სტრინგის და for მარყუჟი ხორციელდება ყოველი სტრინგისთვის და გამოაქვს შედეგი:

```python	
Happy New Year: Joseph
Happy New Year: Glenn
Happy New Year: Sally
Done!
```

for მარყუჟის ინგლისურიდან გადმოთარგმნა არ ხდება ისევე, როგორც while - ის შემთხვევაში, მაგრამ თუ იფიქრებ friends -ზე, როგორც კომპლექტზე, მაშინ გადმოითარგმნება შემდეგნაირად: "კომპლექტში სახელად friends, for მარყუჟის სხეულში თითოეული მეგობრისთვის შეასრულე ბრძანებები”
პითონში for და in არის განსაზღვრული სიტყვები ხოლო friend და friends - ცვლადები.

## 5.7 მარყუჟის ნიმუშები

როცა გვინდა სიაში ვიპოვნოთ უმცირესი ან უდიდესი ელემენტი, ხშირად ვიყენებთ  for ან while მარყუჟს

ეს მარყუჟები ჩვეულებრივ აგებულია:
·         ერთი ან ორი ცვლადის ინიციალიზება სანამ მარყუჟი დაიწყება.
·         მარყუჟის კოდში გამოთვლების შესრულება თითოეული ელემენტისთვის, ცვლადების სავარაუდო შეცვლა მარყუჟის კოდში.
·         Looking at the resulting variables when the loop completes.

გამოვიყენებთ ციფრების სიას მარყუჟის ნიმუშის კონსტრუქციის და კონცეფციის სადემონსტრაციოდ.



## 5.7.1 მთვლელი და შემაჯამებელი მარყუჟები

მაგალითად,  სიაში ელემენტების რაოდენობის დასათვლელად, შეგვეძლო დაგვეწერა მსგავსი for მარყუჟი.

```python	
count = 0
for itervar in [3, 41, 12, 9, 74,15]:
        count = count + 1
print "count: ", count
```

სანამ მარყუჟი დაიწყებოდა, ცვლად count - ს მივანიჭეთ მნიშვნელობა 0, შემდეგ დავწერეთ for მარყუჟი, რომ ემოძრავა ციფრების სიაში. განმეორებად ცვლადს დავარქვით itervar და სანამ მარყუჟში არ ვიყენებთ itervar - ს, არ აკონტროლებს მარყუჟს და ამიტომ მარყუჟის კოდი სიაში ყოველი მნიშვნელობისთვის ხორციელდება ერთხელ. მარყუჟის სხეულში count - ის მნიშვნელობას ვუმატებთ ერთს სიაში თითო მნიშვნელობისთვის. სანამ მარყუჟი ხორციელდება, count - ის მნიშვნელობა არის ციფრი, რომელიც უკვე ვნახეთ. როცა მარყუჟი მორჩება count - ის მნიშვნელობა იქნება ელემენტების რაოდენობის ტოლი. ჩვენ გავაკეთეთ მარყუჟი და როცა მარყუჟში შესრულდება გვქნება ის, რაც გვინდოდა რომ გვქონიყო.


სხვა მსგავსი მარყუჟი, რომელიც ითვლის სიაში არსებული ციფრების ჯამს:

```python	
total = 0
for itervar in [3, 41, 12, 9, 74, 15]:
            total = total + itervar
print 'Total: ', total
```

ამ მარყუჟში გამოვიყენეთ განმეორებადი ცვლადი. ნაცვლად იმისა რომ ერთი დაგვემატებინა count - ისთვის - როგორც წინა მარყუჟში. ჩვენ დავუმატეთ არსებული ციფრები (3, 41, 12, და.ა.შ. ) მთელი მარყუჟის განმავლობაში. თუ ფიქრობ ცვლადზე total, ის შეიცავს “running total of the values so far”.ასე რომ სანამ მარყუჟი დაიწყება total  უდრის  ნულს, იმიტომ რომ ჯერ არცერთი მნიშვნელობა არ გვინახავს. მარყუჟის განმავლობაში total არის მიმდინარე მარყუჟის ჯამი და მარყუჟის ბოლოს total  არის საერთო ჯამი სიაში ყველა მნიშვნელობისა.
როცა კი მარყუჟი განხორციელდება, total  აჯამებს ელემენტებს; ასე გამოყენებულ ცვლადს ხანდახან ეძახიან შემგროვებელს.
არც დამთვლელი და არც შემაჯამებელი მარყუჟები არა არის განსაკუთრებით სასარგებლო პრაქტიკაში, იმიტომ რომ არის ჩაშენებული ფუნქციები len() და sum(), რომელიც ითვლის ელემენტების რაოდენობას სიაში და ელემენტების ჯამს სიაში.

## 5.7.2 მაქსიმუმი და მინიმუმი მარყუჟები

სიაში ან რიგში უდიდესი მნიშვნელობის საპოვნელად ავაგეთ შემდეგი მარყუჟი:

```python	
largest = None
print 'Before:', largest
for itervar in [3, 41, 12, 9, 74, 15]:
            if largest is None or itervar > largest :
                        largest = itervar
            print 'Loop:', itervar, largest
print 'Largest:', largest
```

პროგრამა როცა განხორციელდება ამონაბეჭდი იქნება შემდეგი:

```python	
Before: None
Loop: 3 3
Loop: 41 41
Loop: 12 41
Loop: 9 41
Loop: 74 74
Loop: 15 74
Largest: 74
```


ცვლადი largest  არის საუკეთესო გამოხატულება "უდიდესი მნიშვნელობა რაც აქამდე გვინახავს- ის". მარყუჟამდე largest  მივანიჭეთ მნიშვნელობა None. None არის სპეციალური, მუდმივი მნიშვნელობა, რომელიც შეგვიძლია მივანიჭოთ ცვლადს, ამ ცვლადის - როგორც ცარიელი ცვლადის შესანახად.
სანამ მარყუჟი დაიწყებოდა უდიდესი მნიშვნელობა იყო None. სანამ მარყუჟი ხორციელდება, largest  თუ არის None , მაშინ ვიღებთ პირველ მნიშვნელობას რომელსაც ვხედავთ როგორც უდიდესს . პირველ გამეორებაში როცა itervar  არის 3,  მაშ შემდეგ largest არის  None , მყისიერად ვანიჭებთ largest - ს მნიშვნელობას 3.
პირველი გამეორების შემდეგ largest აღარ არის  None,  ლოგიკური გამოსახულების მეორე ნაწილი ამოწმებს itervar > largest და მოქმედებს მაშინ, როცა მნიშვნელობა უფრო დიდია ვიდრე აქამდე გვენახა. როცა ვხედავთ უფრო დიდ მნიშვნელობას, ვიღებთ ახალ მნიშვნელობას ცვლადისთვის largest. პროგრამის ამონაბეჭდში შეგიძლია ნახო largest არის 3 - დან 41 და 74 - მდე.
მარყუჟის ბოლოში შევამოწმეთ ყველა მნიშვნელობა და ცვლადი largest - ს ენიჭება სიაში უდიდესის მნიშვნელობებად.
უმცირესი ციფრის გამოსათვლელად კოდი არის თითქმის იგივე:

```python	
smallest = None
print 'Before:', smallest
for itervar in [3, 41, 12, 9, 74, 15]:
      if smallest is None or itervar < smallest:
            smallest = itervar
      print 'Loop:', itervar, smallest
print 'Smallest:', smallest
```

Again, smallest is the “smallest so far” before, during, and after the loop executes.

როცა მარყუჟი სრულდება, smallest -ს  ენიჭება სიაში უმცირესის მნიშვნელობა.
როგორც დათვლის და შეჯამების ფუნქციები, ჩაშენებული ფუნქციები max() და min() ამ მარყუჟების დაწერას ხდის ზედმეტს.

შემდეგი კოდი min() ფუნქციის მარტივი ვერსიაა:

```python	
def min(values):
      smallest = None
      for value in values:
            if smallest is None or value < smallest:
                  smallest = value
      return smallest
```

ფუნქციურ ვერსიაში print ბრძანებები მოვაშორეთ.

## 5.8 გამართვა

როცა უფრო დიდი პროგრამების წერას დაიწყებ, აღმოაჩენ რომ უფრო მეტ დროს ხარჯავ გამართვაში. მეტი კოდი ნიშნავს შეცდომის დაშვების მეტ შანსს და მეტ ადგილს ნაკლთა დასამალად.
გამართვის დროის შესამცირებელი ერთი გზაა "გამართვა შუაზე გაყოფით"(?) (“debugging by bisection.”). მაგალითად პროგრამაში 100 ხაზი თუა და შეამოწმებ სათითაოდ, ამას მოუნდება 100 ნაბიჯი. ამის მაგივრად ცადე პრობლემა გაყო შუაზე. მონახე პროგრამის შუა ნაწილი შუალედური მნიშვნელობისათვის, რომლის შემოწმებაც შეგიძლია. დაამატე print ბრძანება (ან სხვა რამე, რასაც დამამოწმებელის ეფექტი ექნება) და პროგრამა გაუშვი. შუა წერტილის შემოწმება თუ შეცდომას აჩვენებს, პრობლემა უნდა იყოს კოდის პირველ ნაწილში და  თუ შემოწმება სწორია , მაშინ - მეორე ნაწილში.
ყოველ ჯერზე როცა ამოწმებ ამ მეთოდით, ანახევრებ ხაზებს, საცა უნდა მოძებნო პრობლემა. 6 ნაბიჯის შემდეგ(რაც ბევრად ნაკლებია ვიდრე 100)   იქნები 1-2 ხაზით დაბლა თეორიულად მაინც.
პრაქტიკაში ყოველთვის არ არის ცხადი თუ სადაა "პროგრამის შუა" და შემოწმება ყოველთვის არ არის შესაძლებელი. ხაზების დათვლას და ზუსტად შუა წერტილის პოვნას აზრი არ აქვს. სანაცვლოდ იფიქრე პროგრამაში ადგილებზე, სადაც შეიძლება შეცდომები იყოს და ადგილებზე, სადაც შემოწმება ადვილია.

## 5.9 ლექსიკონი

accumulator: მარყუჟში გამოყენებული ცვლადი, რომელშიც შეიტან ან ჩაუმატებ შედეგს.
counter: მარყუჟში გამოყენებული ცვლადი ხდომილებათა რაოდენობის დასათვლელად.  მთვლელს ვაყენებთ ნულზე და შემდეგ, როცა გვინდა რამე დათვალოს მთვლელს ყოველ ჯერზე ვზრდით.
decrement: განახლება, რომელიც ცვლადის მნიშვნელობას ამცირებს.
initialize: ტოლობა, რომელიც ცვლადს აძლევს საწყის მნიშვნელობას - რომელიც განახლდება.
increment: განახლება, რომელიც ზრდის ცვლადის მნიშვნელობას (ხშირად ერთით)
infinite loop: მარყუჟი, რომელშიც შეჩერების პირობა არასდროს შესრულდება.
iteration: მიცემული ბრძანებების გამეორებადი განხორციელება რეკურსიული ფუნქციის გამოძახებით ან მარყუჟით.

შენიშვნა: რეკურსიული ფუნქცია ეწოდება ისეთ ფუნქციას რომელიც იძახებს საკუთარ თავს, მისი მთავარი იარაღია ამოცანის მარტივ ნაწილებად დაშლა ანუ დეკომპოზიცია. რეკურსია მოქმედებს პრინციპით “დაყავი და იბატონე”. რეკურსიული ფუნქციის დასრულება ხდება ამოცანის საბაზო ანუ ყველაზე მარტივ დონემდე დაყვანით. ამოცანის რეკურსიულად გადაწყვეტა მოითხოვს გაცილებით დიდ რესურსებს კომპიუტერისგან, ვიდრე ამას საჭიროებს ტრადიციული(იტერაციული) მიდგომა, თუმცა უნდა აღინიშნოს რომ ზოგიერთი ამოცანის გადაწყვეტისას რეკურსიული მიდგომა გაცილებით უკეთესია, ვიდრე იტერაციული.

